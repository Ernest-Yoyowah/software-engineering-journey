# Algorithms Overview

## Sorting Algorithms

Sorting algorithms are used to rearrange a collection of items in a specific order.

Common sorting algorithms include:

- Bubble Sort
- Selection Sort
- Insertion Sort
- Merge Sort
- Quick Sort
- Heap Sort

These algorithms vary in their efficiency (time complexity) and suitability for different types of data and input sizes.

## Searching Algorithms

Searching algorithms are used to find a specific target within a collection of items.

Common searching algorithms include:

- Linear Search
- Binary Search (applicable only on sorted collections)
- Depth-First Search (DFS)
- Breadth-First Search (BFS)

Searching algorithms can be categorized based on their time complexity and the structure of the data they operate on.

## Graph Algorithms

Graph algorithms are used to traverse and manipulate graphs, which consist of vertices/nodes connected by edges.

Common graph algorithms include:

- Depth-First Search (DFS)
- Breadth-First Search (BFS)
- Dijkstra's Algorithm (for finding shortest paths in weighted graphs)
- Bellman-Ford Algorithm (for finding shortest paths with negative weights)
- Prim's Algorithm (for finding minimum spanning trees)
- Kruskal's Algorithm (for finding minimum spanning trees)
- Floyd-Warshall Algorithm (for finding all-pairs shortest paths)

Graph algorithms are essential for solving problems involving networks, routing, scheduling, and more.

## Dynamic Programming

Dynamic programming is a technique used to solve problems by breaking them down into simpler subproblems and solving each subproblem only once, storing the results to avoid redundant computations.

Common dynamic programming problems include:

- Fibonacci Sequence
- Longest Common Subsequence
- Knapsack Problem
- Shortest Path Problems (e.g., Floyd-Warshall Algorithm)
- Edit Distance

Dynamic programming can significantly improve the efficiency of algorithms by avoiding redundant calculations.

## Greedy Algorithms

Greedy algorithms make locally optimal choices at each step with the hope of finding a global optimum solution.

Common greedy algorithms include:

- Dijkstra's Algorithm (for finding single-source shortest paths in non-negative weighted graphs)
- Prim's Algorithm (for finding minimum spanning trees)
- Kruskal's Algorithm (for finding minimum spanning trees)
- Huffman Coding (for data compression)
- Activity Selection Problem

Greedy algorithms are often straightforward to implement and can provide efficient solutions for many optimization problems, although they may not always guarantee the globally optimal solution.
