# Requirements Gathering and Specification

## Key Topics

### Natural Language vs. Modeled Requirements

1. **Natural Language Requirements**:

   - Simple textual descriptions of what the system should do.
   - Can lead to ambiguity and misinterpretation if not written carefully.

2. **Modeled Requirements**:
   - Use visual or structured representations to reduce ambiguity. Examples:
     - **Graphs** (e.g., UML diagrams): Represent system interactions and workflows.
     - **Mathematical Formulas**: Used for precise system properties (e.g., algorithms).
     - **Code/Pseudo-Code**: Provide prototypes for better clarity.

---

### Software Engineering Phases

1. **Requirements Engineering**: Define what the system should do.
2. **Design**: Plan how the system will achieve its objectives.
3. **Implementation**: Code and build the system.
4. **Testing**: Verify and validate the system functionality.
5. **Deployment**: Deliver the system to end users.
6. **Maintenance**: Ensure the system remains functional and updated over time.

---

### Requirements Engineering Subprocesses

1. **Requirements Elicitation**:

   - Gathering requirements from stakeholders using techniques like interviews, surveys, or observations.

2. **Requirements Analysis**:

   - Identifying inconsistencies, prioritizing needs, and ensuring feasibility.

3. **Requirements Documentation**:

   - Writing clear and structured documents (e.g., SRS).

4. **Verification and Validation**:
   - **Verification**: "Are we building the system right?" (ensuring it meets design specs).
   - **Validation**: "Are we building the right system?" (ensuring it meets user needs).

---

### Common Problems in Requirements Engineering

1. **Incomplete or Hidden Requirements**: Stakeholders fail to disclose all needs.
2. **Inconsistent Requirements**: Conflicting needs between stakeholders.
3. **Terminology Issues**: Different understanding of terms between teams or organizations.
4. **Unclear Responsibilities**: Uncertainty about who is responsible for certain requirements.
5. **Communication Gaps**: Poor communication leads to misunderstandings.
6. **Moving Targets**: Stakeholder opinions and requirements change over time.
7. **Technically Unfeasible Requirements**: Unrealistic demands due to technical constraints.
8. **Unclear Stakeholder Needs**: Stakeholders themselves are unsure of their exact requirements.
9. **Underspecified Requirements**: Requirements lack sufficient detail for implementation.
10. **Unclear Functional Requirements**: Ambiguity in measurable or testable functions.

---

## Generic Process Model

### Artifacts

- **Documents**: SRS, user stories, use cases.
- **Diagrams**: UML, data flow diagrams, prototypes.

### Activities and Methods

- **Activities**: Elicitation, analysis, documentation, validation, and management.
- **Methods**: Interviews, brainstorming, prototyping, scenario analysis.

### Roles and Responsibilities

- **Stakeholders**: Provide input on system needs.
- **Requirements Engineer**: Collect, analyze, and document requirements.
- **Developers**: Implement the system based on specifications.
- **Testers**: Ensure the system meets documented requirements.

### Tools

- Requirement management software (e.g., JIRA, Trello).
- Diagramming tools (e.g., Lucidchart, Draw.io).

### Milestones

- Approved SRS.
- Completion of requirement validation.
- Sign-off from stakeholders.

---

## Process and Principles

1. **Activity vs. Artifact Orientation**:

   - **Activity Orientation**: Focus on actions performed (e.g., writing use cases).
   - **Artifact Orientation**: Focus on deliverables created (e.g., completed SRS).

2. **Problem vs. Solution Orientation**:
   - **Problem Orientation**: Understand and define the problem before jumping into solutions.
   - **Solution Orientation**: Develop a solution that directly addresses the identified problem.

---
